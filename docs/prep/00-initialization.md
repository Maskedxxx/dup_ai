# Предшаг: инициализация приложения

## Что происходит при запуске
- Загружаем настройки: читаются переменные из `.env`, создаются `AppSettings`, `LLMSettings`, `Contractor/Risk/Error/ProcessSettings`. Это даёт пути к Excel, лимиты результатов, адрес и модель LLM.
- Включаем единый логгер: создаётся папка `LOGS`, файл `LOGS/dup_ai.log` и формат логов. Все модули пишут в один лог с начала работы.
- Собираем приложение: инициализируется `FastAPI` и подключается роутер API v1.
- Готовим DI-контейнер: при импорте API выполняется регистрация фабрик зависимостей (как создавать объекты), но сами объекты ещё не создаются.
- Готовность: сервер слушает порт и ждёт первый запрос.

## Где в коде
- Настройки: `app/config.py` (классы настроек и их экземпляры; `classification_config`, `smart_filtering_settings`).
- Логирование: `app/utils/logging.py` (единый логгер `dup_ai`, файл `LOGS/dup_ai.log`).
- Приложение: `app/main.py` (`load_dotenv`, создание `FastAPI`, `include_router`).
- Регистрация зависимостей: `app/api/v1/endpoints.py` вызывает `init_container()`; реализация — в `app/pipelines/__init__.py`.

## Что такое «фабрики» и зачем
- Определение: фабрика — это функция «как создать объект» (например, `ExcelLoader()`), которую мы регистрируем в DI-контейнере (`container.register_factory(...)`).
- Зачем:
  - Ленивая инициализация: объекты создаются только когда реально понадобятся (быстрый старт, экономия памяти/CPU).
  - Заменяемость: легко подменить реализацию (например, другой `LLMClient`) без изменений остального кода.
  - Тестируемость: в тестах можно зарегистрировать заглушки/моки вместо реальных классов.
  - Централизация: вся «сборка» зависимостей в одном месте, проще сопровождать.
- Где: регистрация фабрик для `ExcelLoader`, `LLMClient`, сервисов нормализации/классификации/генерации, `ToolExecutor` — в `init_container()` (`app/pipelines/__init__.py`).

## Что такое «пайплайны» и зачем
- Определение: пайплайн — это класс, который инкапсулирует 8 шагов обработки данных: загрузка → нормализация → предобработка → подготовка элементов → классификация → фильтрация (+ умная) → модели → ответ.
- Виды: `ContractorsPipeline`, `RisksPipeline`, `ErrorsPipeline`, `ProcessesPipeline` — один интерфейс `process(question, ...)` для всех кнопок.
- Состав: каждый пайплайн получает из контейнера адаптер (`ExcelLoader`), сервисы (`...Normalization`, `...Classifier`, `...AnswerGenerator`) и `ToolExecutor` (для умной фильтрации).
- Зачем:
  - Единый контракт: любой тип данных обрабатывается одинаково, UI/APИ не завязаны на детали.
  - Локализация логики: различия по доменам изолированы внутри конкретного пайплайна.
  - Расширяемость: легко добавить новый пайплайн (например, «метрики») без изменений ядра.
- Где: базовая логика — `app/pipelines/base.py` (`BasePipeline.process()` с пронумерованными шагами); выбор пайплайна по кнопке — в `get_pipeline()` (`app/pipelines/__init__.py`).

## Почему так
- Быстрый старт: тяжёлые вещи (чтение Excel, инициализация KeyBERT/LLM) выполняются только по запросу.
- Прозрачность: пошаговое логирование пайплайна упрощает поддержку и поиск ошибок.
- Гибкость: DI + фабрики позволяют конфигурировать реализацию без переписывания кода.

## Что важно знать
- `KeyBERTService` и `LLMClient` создаются при первом использовании соответствующих шагов.
- Ошибки конфигурации `.env` видны сразу в логах при старте или при первом запросе.
