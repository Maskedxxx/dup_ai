# Детальный анализ работы пайплайна обработки рисков

Этот документ описывает полный цикл обработки запроса, связанного с рисками, от получения API-запроса до генерации финального ответа.

## 1. Входная точка: API Эндпоинт

- **Файл:** `app/api/v1/endpoints.py`
- **Функция:** `ask(request: AskRequest, ...)`

Процесс начинается, когда пользователь отправляет POST-запрос на эндпоинт `/v1/ask`.

1.  **Определение типа запроса:** Функция `ask` анализирует тело запроса, в частности поле `request.button`. Если значение этого поля равно `ButtonType.RISKS`, система понимает, что нужно обработать запрос о рисках.
2.  **Выбор обработчика:** Словарь `BUTTON_PROCESSORS` сопоставляет тип кнопки с соответствующей логикой. Для `ButtonType.RISKS` вызывается лямбда-функция: `lambda pipeline, req: pipeline.process(req.question, req.risk_category)`.
3.  **Получение пайплайна:** Перед вызовом обработчика, функция `get_pipeline(request.button, request.risk_category)` вызывается для создания и настройки необходимого пайплайна.

## 2. Фабрика пайплайнов

- **Файл:** `app/pipelines/__init__.py`
- **Функция:** `get_pipeline(button_type: ButtonType, ...)`

Эта функция отвечает за создание экземпляра нужного пайплайна с внедрением всех необходимых зависимостей.

1.  **Выбор класса пайплайна:** На основе `button_type` (`ButtonType.RISKS`) из словаря `BUTTON_TO_PIPELINE` выбирается класс `RisksPipeline`.
2.  **Создание зависимостей:** Функция использует DI-контейнер (`container`) для получения экземпляров всех необходимых сервисов:
    -   `ExcelLoader`: для загрузки данных из Excel.
    -   `RiskNormalizationService`: для нормализации текста.
    -   `RiskClassifierService`: для классификации запроса по проектам.
    -   `RiskAnswerGeneratorService`: для формирования ответа.
    -   `ToolExecutor`: для выполнения интеллектуальных инструментов анализа.
3.  **Инстанцирование пайплайна:** Создается экземпляр `RisksPipeline`, в конструктор которого передаются все созданные выше сервисы.

## 3. Основной пайплайн: `RisksPipeline`

- **Файл:** `app/pipelines/risks_pipeline.py`
- **Класс:** `RisksPipeline`
- **Метод:** `process(self, question: str, risk_category: RiskCategory)`

Это ядро обработки запроса о рисках. Метод `process` оркестрирует весь процесс, вызывая унаследованную логику из `BasePipeline`, которая выполняет шаги в строгом порядке.

1.  **Предварительная обработка (`_pre_process_dataframe`):** Исходный DataFrame, загруженный из Excel, фильтруется по `risk_category`, указанной в запросе. Это сужает область поиска до релевантной категории проектов.
2.  **Загрузка классификатора (`_load_classifier_items`):** Названия проектов из отфильтрованного DataFrame загружаются в `RiskClassifierService` для последующей классификации.
3.  **Фильтрация данных (`_filter_data`):** Это двухэтапный процесс фильтрации:
    -   **Этап 1: Классификация по проекту.** `RiskClassifierService` определяет, к какому проекту относится вопрос пользователя, и фильтрует DataFrame, оставляя только риски, связанные с этим проектом.
    -   **Этап 2: Интеллектуальная фильтрация.** Вызывается `self.tool_executor.select_and_execute`. Этот метод использует инструменты для более глубокого анализа отфильтрованных на первом этапе данных. Набор доступных инструментов определяется методом `get_tool_names()`, который для рисков возвращает `CommonToolSets.RISK_ANALYSIS`.
4.  **Генерация контекста (`_generate_additional_context`):** Создается дополнительная текстовая информация для LLM, например: "Найдено 5 рисков для проекта 'Проект X' в категории 'Строительство'".
5.  **Генерация ответа (`_generate_answer`):** `RiskAnswerGeneratorService` использует отфильтрованные данные и дополнительный контекст для формирования финального ответа в формате Markdown.

## 4. Набор инструментов: `CommonToolSets`

- **Файл:** `app/tools/common_toolsets.py`
- **Класс:** `CommonToolSets`

Этот класс определяет, какие инструменты доступны для каждого пайплайна.

-   Для пайплайна рисков используется набор `RISK_ANALYSIS`, который в текущей реализации содержит только один инструмент: `"search_by_keywords"`.

## 5. Исполнитель инструментов: `ToolExecutor`

- **Файл:** `app/tools/tool_executor.py`
- **Класс:** `ToolExecutor`
- **Метод:** `select_and_execute(...)`

Этот компонент отвечает за выполнение инструментов.

1.  **Извлечение ключевых слов:** Вместо того чтобы просить LLM выбрать инструмент, текущая реализация напрямую использует сервис `keybert_service` для извлечения ключевых слов из вопроса пользователя (`question`).
2.  **Выбор инструмента:** Система проверяет, доступен ли инструмент `"search_by_keywords"` в списке разрешенных для пайплайна.
3.  **Выполнение инструмента:** Если инструмент доступен, он получается из реестра (`tool_registry`) и выполняется с извлеченными ключевыми словами в качестве аргументов.

## 6. Инструмент поиска: `KeywordSearchTool`

- **Файл:** `app/tools/keyword_search_tool.py`
- **Класс:** `KeywordSearchTool`
- **Метод:** `execute(self, df: pd.DataFrame, keywords: List[str], ...)`

Это финальный этап, где происходит непосредственный поиск по данным.

1.  **Лемматизация:** Для более точного и гибкого поиска инструмент приводит ключевые слова из запроса и тексты рисков в колонке `risk_text` к их нормальной (словарной) форме. Например, слова "риски", "рискам", "рискованный" превратятся в "риск".
2.  **Расчет релевантности (`calculate_relevance_score`):** Для каждой записи (риска) в DataFrame вычисляется оценка релевантности на основе того, сколько лемматизированных ключевых слов было найдено в лемматизированном описании риска.
3.  **Фильтрация и сортировка:** Записи с нулевой релевантностью отбрасываются. Оставшиеся сортируются по убыванию оценки, и возвращается топ-N наиболее релевантных результатов.
